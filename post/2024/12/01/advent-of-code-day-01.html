<!DOCTYPE html><html lang=en-GB><head><meta name=viewport content="width=device-width, initial-scale=1"><meta name=keywords content=""><meta name=no-email-collection content="/privacy.txt"><meta name=twitter:card content=summary_large_image><meta property=og:title content="Advent of Code 2024 - Day 1 • Greg Daynes"><meta property="og:description" name=description content="The website and home of Gregory Daynes. Find links to projects, notebooks, and resume."><meta property="og:image" content="data:;base64,iVBORw0KGgo="><title>Advent of Code 2024 - Day 1 • Greg Daynes</title><link rel=me href="//mastodon.social/@gregdaynes"><link rel=author href="/humans.txt"><link rel=icon href="data:;base64,iVBORw0KGgo="><link type="application/atom+xml" rel=alternate href="/feed.xml"><link rel=stylesheet href="/assets/css/variables-critical-text-fit-toc-list-88113d.css"><style>code{font-size:.9em}p>code{background:var(--_color-background-code)}div.highlight{overflow:scroll;background:var(--_color-background-code)}pre{margin-block:0;padding:var(--s-1);border-radius:3px;overflow-x:auto}.footnotes p{margin-block-end:0}blockquote{border-inline-start:4px solid;padding-inline-start:1rem;margin-inline:auto;font-weight:bold;font-style:italic}</style></head><body class="page advent-of-code-2024---day-1"><img src="//analytics.app.gregdaynes.com?type=image&page=/post/2024/12/01/advent-of-code-day-01.html" width=0 height=0 /><header><h1 class=text-fit><span><a data-text="Greg Daynes" href="/">Greg Daynes</a></span><span aria-hidden=true style="visibility: hidden">Greg Daynes</span></h1><p class=text-fit><span><span>Full Stack Software Design, Development & Management</span></span><span aria-hidden=true style="visibility: hidden">Full Stack Software Design, Development & Management</span></p><nav><ul><li><a href="/">Home</a></li><li><a href="/about">About</a></li><li><a href="/resume">Resume</a></li><li><a href="/projects">Projects</a></li><li><a href="/notebook">Notebook</a></li></ul></nav></header><div class=with-sidebar><main><article><h2>Advent of Code 2024 - Day 1</h2><ul id=markdown-toc><li><a href="#introduction" id=markdown-toc-introduction>Introduction</a></li><li><a href="#solving-day-1" id=markdown-toc-solving-day-1>Solving Day 1</a><ul><li><a href="#day-1-part-1" id=markdown-toc-day-1-part-1>Day 1: Part 1</a><ul><li><a href="#first-pass" id=markdown-toc-first-pass>First Pass</a></li><li><a href="#second-pass" id=markdown-toc-second-pass>Second Pass</a></li></ul></li><li><a href="#day-1-part-2" id=markdown-toc-day-1-part-2>Day 1: Part 2</a><ul><li><a href="#first-pass-1" id=markdown-toc-first-pass-1>First pass</a></li><li><a href="#second-pass-1" id=markdown-toc-second-pass-1>Second pass</a></li><li><a href="#third-pass" id=markdown-toc-third-pass>Third Pass</a></li><li><a href="#fourth-pass" id=markdown-toc-fourth-pass>Fourth pass</a></li><li><a href="#fifth-pass-for-funzies" id=markdown-toc-fifth-pass-for-funzies>Fifth pass (for funzies)</a></li></ul></li></ul></li><li><a href="#summary--timings" id=markdown-toc-summary--timings>Summary &amp; Timings</a><ul><li><a href="#additional-findings" id=markdown-toc-additional-findings>Additional Findings</a></li></ul></li></ul><h3 id=introduction>Introduction</h3><p>Each time Advent of Code comes around, I have the intention of participating, read the first puzzle, maybe solve it and then forget to continue through the rest.</p><p>There’s a few culprits to my abandonment.</p><ul><li><em>Attention</em>; usually work or other tasks get in the way.</li><li><em>Steep Cliff</em>; the puzzles are a wall of text that I find intimidating.</li><li><em>Imposter Syndrome</em>; I’m not good enough to do it good so I shouldn’t do it at all.</li><li><em>Learning languages</em>; I tend to want to pick up a new language, but get distracted by learning it instead of applying as I’m going.</li><li>But it’s mostly work and free time.</li></ul><p>This year is different. It overlaps with funemployment! Which means I don’t have much preventing me from bashing out some terrible solutions.</p><p>As solutions to the above:</p><ul><li>I am going to do it in NodeJS, removing the language distraction.</li><li>Wall of text; behavioural changes are hard, reading comprehension on meandering text is a struggle. Perhaps a symptom of an undiagnosed attention problem. Instead of trying to find problem solving algorithms; start with solving the problem. Make it better. Maybe an algorithm will emerge, this is practice and should be fun. So have at it!</li></ul><h3 id=solving-day-1>Solving Day 1</h3><p>Code for <a href="//github.com/gregdaynes/advent-of-code-2024/tree/day01">Day 01</a></p><h4 id=day-1-part-1>Day 1: Part 1</h4><p>Given an input with 2 columns of numbers (2 numbers per line). Find the distance between the first lowest of each column. Find the distance between the second lowest of each column. Repeat for each set of numbers. Return the sum of the distances.</p><hr/><h5 id=first-pass>First Pass</h5><p>Bash out a solution, improve later.</p><div class="language-js highlighter-rouge"><div class=highlight><pre class=highlight><code><span class="kd">function</span> <span class="nf">solve</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">pairs</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="se">\n</span><span class="dl">'</span><span class="p">)</span>

  <span class="kd">const</span> <span class="nx">leftCollection</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kd">const</span> <span class="nx">rightCollection</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">pair</span> <span class="k">of</span> <span class="nx">pairs</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">]</span> <span class="o">=</span> <span class="nx">pair</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="dl">'</span><span class="s1">   </span><span class="dl">'</span><span class="p">)</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">left</span> <span class="o">||</span> <span class="o">!</span><span class="nx">right</span><span class="p">)</span> <span class="k">continue</span>

    <span class="nx">leftCollection</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span>
    <span class="nx">rightCollection</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">leftCollection</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span>
  <span class="nx">rightCollection</span><span class="p">.</span><span class="nf">sort</span><span class="p">()</span>

  <span class="kd">let</span> <span class="nx">distanceAcc</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">while</span><span class="p">(</span><span class="nx">leftCollection</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">distanceAcc</span> <span class="o">+=</span> <span class="nb">Math</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span>
      <span class="nx">leftCollection</span><span class="p">.</span><span class="nf">shift</span><span class="p">()</span> <span class="o">-</span> <span class="nx">rightCollection</span><span class="p">.</span><span class="nf">shift</span><span class="p">()</span>
    <span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">distanceAcc</span>
<span class="p">}</span>
</code></pre></div></div><p>This is awful, doesn’t scale well, but does solve the problem.</p><p>The first offence is splitting the input on new line into an array. Already we’ve introduced memory issues - what if the input in many GBs? Looking at the known inputs, we’re safe, so we don’t have to be proactive (or defensive) here. If this was real-life code, I’d want more samples, or at least ask what the maximum size will be.</p><p>Next are the creation of 2 arrays - seems harmless. Paired with iterating the split array, performing a split on each entry and then putting the values into the corresponding array is probably fine.</p><p>We then sort each array as a mutation. This could be done without the mutation, but we’d double up memory again. So now we have input string, input array, left array, right array. We’ve iterated each array at once, meaning we’ve done 3*n operations.</p><p>Finally looping over all items in the left array, but doing another mutation of both left and right to get the first entries each step. Knowing javascript array mutation isn’t the fastest, a better option would probably be to reverse the sort direction so lowest value is last and then using pop instead of shift to remove the entry.</p><h5 id=second-pass>Second Pass</h5><div class="language-plaintext highlighter-rouge"><div class=highlight><pre class=highlight><code>function solve (input) {
  const regex = /(?&lt;left&gt;\d+)\s+(?&lt;right&gt;\d+)/gm

  const Left = []
  const Right = []

  ;[...input.matchAll(regex)]
    .forEach(({  groups: { left, right } }) =&gt; {
      Left.push(left)
      Right.push(right)
    })

  Left.sort()
  Right.sort()

  let distanceAcc = 0

  for (const i in Left) {
    distanceAcc = distanceAcc + Math.abs(Left[i] - Right[i])
  }

  return distanceAcc
}
</code></pre></div></div><p>A bit better.</p><p>Instead of splitting the input into an array based on new lines, and then iterating each line and splitting based on separator, Regex gives us the ability grab each number on each line directly. There is still the input size problem, but can ignore it based on what we know.</p><p>We still have the 2 arrays, and the sorting problem - I don’t see a way out of it.</p><p>Iteration to create the sum is no longer in a while loop - this doesn’t really matter.</p><p>No longer mutating the arrays, instead using the index of the loop to lookup the values. Seems fine.</p><p><em>If input happened to be too much to hold in memory, NodeJS FileSystem Readline stream would be a good approach. The regex is still usable, but doesn’t need to be multi-line</em></p><p>Rough timing through <code class="language-plaintext highlighter-rouge">node:test</code> reveals the <code class="language-plaintext highlighter-rouge">second pass</code> is slightly faster.</p><table><thead><tr><th>pass</th><th>time (ms)</th></tr></thead><tbody><tr><td>1: sample dataset</td><td>0.526166</td></tr><tr><td>2: sample dataset</td><td>0.192042</td></tr><tr><td>1: actual dataset</td><td>1.409791</td></tr><tr><td>2: actual dataset</td><td>1.182459</td></tr></tbody></table><p>Just over 1ms to work through 1000 rows of numbers isn’t exactly performant. But good enough.</p><h4 id=day-1-part-2>Day 1: Part 2</h4><p>Same as part 1, except instead summing distances between the numbers. Score the lowest number in the left column through multiplication of the occurrances in the right. Finally sum the scores.</p><h5 id=first-pass-1>First pass</h5><div class="language-js highlighter-rouge"><div class=highlight><pre class=highlight><code><span class="kd">function</span> <span class="nf">solve</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">regex</span> <span class="o">=</span> <span class="sr">/</span><span class="se">(?&lt;</span><span class="sr">left&gt;</span><span class="se">\d</span><span class="sr">+</span><span class="se">)\s</span><span class="sr">+</span><span class="se">(?&lt;</span><span class="sr">right&gt;</span><span class="se">\d</span><span class="sr">+</span><span class="se">)</span><span class="sr">/gm</span>

  <span class="kd">const</span> <span class="nx">Left</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kd">const</span> <span class="nx">Right</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="p">;[...</span><span class="nx">input</span><span class="p">.</span><span class="nf">matchAll</span><span class="p">(</span><span class="nx">regex</span><span class="p">)]</span>
    <span class="p">.</span><span class="nf">forEach</span><span class="p">(({</span>  <span class="na">groups</span><span class="p">:</span> <span class="p">{</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="p">}</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">Left</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span>
      <span class="nx">Right</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span>
    <span class="p">})</span>

  <span class="kd">let</span> <span class="nx">similarity</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">left</span> <span class="k">of</span> <span class="nx">Left</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">occurrances</span> <span class="o">=</span> <span class="nx">Right</span><span class="p">.</span><span class="nf">filter</span><span class="p">((</span><span class="nx">right</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">left</span> <span class="o">===</span> <span class="nx">right</span><span class="p">).</span><span class="nx">length</span>
    <span class="nx">similarity</span> <span class="o">+=</span> <span class="nx">left</span> <span class="o">*</span> <span class="nx">occurrances</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">similarity</span>
<span class="p">}</span>
</code></pre></div></div><p>Chuffed with the regex solution for creating two arrays of numbers, I will keep that.</p><p>Scoring iterates over the left array and uses Array.filter to produce a new array of matching values. Taking the size of resulting array and doing the scoring. Back to iterating each array many times. Seems fine with the test dataset, but actual dataset is very slow.</p><p>This can be improved.</p><h5 id=second-pass-1>Second pass</h5><div class="language-js highlighter-rouge"><div class=highlight><pre class=highlight><code><span class="kd">function</span> <span class="nf">solve</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">regex</span> <span class="o">=</span> <span class="sr">/</span><span class="se">(?&lt;</span><span class="sr">left&gt;</span><span class="se">\d</span><span class="sr">+</span><span class="se">)\s</span><span class="sr">+</span><span class="se">(?&lt;</span><span class="sr">right&gt;</span><span class="se">\d</span><span class="sr">+</span><span class="se">)</span><span class="sr">/gm</span>

  <span class="k">return</span> <span class="p">[...</span><span class="nx">input</span><span class="p">.</span><span class="nf">matchAll</span><span class="p">(</span><span class="nx">regex</span><span class="p">)]</span>
    <span class="p">.</span><span class="nf">reduce</span><span class="p">((</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">current</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="p">[</span><span class="nx">_</span><span class="p">,</span> <span class="nx">left</span><span class="p">]</span> <span class="o">=</span> <span class="nx">current</span>
      <span class="kd">const</span> <span class="nx">rightMatch</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RegExp</span><span class="p">(</span><span class="dl">"</span><span class="se">\\</span><span class="s2">W(</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">left</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">)$</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">gm</span><span class="dl">"</span><span class="p">)</span>
      <span class="kd">const</span> <span class="nx">count</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">input</span><span class="p">.</span><span class="nf">matchAll</span><span class="p">(</span><span class="nx">rightMatch</span><span class="p">)].</span><span class="nx">length</span>

      <span class="k">return</span> <span class="nx">acc</span> <span class="o">+</span> <span class="nx">left</span> <span class="o">*</span> <span class="nx">count</span>
    <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div><p>Reducers to the rescue!</p><p>The code is much more compact, cool I guess, but there are some new problems.</p><p>The reducer is being used correctly, nothing wrong there</p><p>The first problem is constructing a new regex pattern in each loop containing the left column value to find in the right column. This has a small cost to it, but it’s notable.</p><p>We then apply that match against the whole input - while it’s a string, this is almost the same as looking through the right array with the filter each time, but we have a more complex operation, and do it on the entire dataset.</p><p>I had hopes this would be better, but is so much worse.</p><h5 id=third-pass>Third Pass</h5><div class="language-js highlighter-rouge"><div class=highlight><pre class=highlight><code><span class="kd">function</span> <span class="nf">solve</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">regex</span> <span class="o">=</span> <span class="sr">/</span><span class="se">(?&lt;</span><span class="sr">left&gt;</span><span class="se">\d</span><span class="sr">+</span><span class="se">)\s</span><span class="sr">+</span><span class="se">(?&lt;</span><span class="sr">right&gt;</span><span class="se">\d</span><span class="sr">+</span><span class="se">)</span><span class="sr">$/gm</span>

  <span class="kd">const</span> <span class="nx">Left</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kd">const</span> <span class="nx">Right</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Map</span><span class="p">()</span>

  <span class="p">;[...</span><span class="nx">input</span><span class="p">.</span><span class="nf">matchAll</span><span class="p">(</span><span class="nx">regex</span><span class="p">)]</span>
    <span class="p">.</span><span class="nf">forEach</span><span class="p">(({</span>  <span class="na">groups</span><span class="p">:</span> <span class="p">{</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="p">}</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">Left</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span>

      <span class="k">if </span><span class="p">(</span><span class="nx">Right</span><span class="p">.</span><span class="nf">has</span><span class="p">(</span><span class="nx">right</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">Right</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">right</span><span class="p">,</span> <span class="nx">Right</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">Right</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">right</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">})</span>

  <span class="kd">let</span> <span class="nx">similarity</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">left</span> <span class="k">of</span> <span class="nx">Left</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">occurrances</span> <span class="o">=</span> <span class="nx">Right</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">occurrances</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">similarity</span> <span class="o">+=</span> <span class="nx">left</span> <span class="o">*</span> <span class="nx">occurrances</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">similarity</span>
<span class="p">}</span>
</code></pre></div></div><p>Being let down with the reducer, and regex, I spent a moment to think what a faster operation would be.</p><p><em>Why not count occurrences as we’re iterating to produce the 2 arrays?</em></p><p>Using a map, with the number as the key and the occurrences as the value - each occurrence increments the value.</p><p>There’s no need to store all the right numbers anymore, duplicates are removed. Awesome.</p><p>Now the scoring is a quick lookup of the map for the left number.</p><p>Initial testing of this revealed that it was faster than the reducer on the test set, but still slower than the first pass with the array filter. <em>This is why real data is important to work with too</em> - This approach is much faster than the approach one and two with the actual data.</p><h5 id=fourth-pass>Fourth pass</h5><p>Maps are weird, what about an object that behaves the same?</p><div class="language-js highlighter-rouge"><div class=highlight><pre class=highlight><code><span class="kd">function</span> <span class="nf">solve</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">regex</span> <span class="o">=</span> <span class="sr">/</span><span class="se">(?&lt;</span><span class="sr">left&gt;</span><span class="se">\d</span><span class="sr">+</span><span class="se">)\s</span><span class="sr">+</span><span class="se">(?&lt;</span><span class="sr">right&gt;</span><span class="se">\d</span><span class="sr">+</span><span class="se">)</span><span class="sr">$/gm</span>

  <span class="kd">const</span> <span class="nx">Left</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kd">const</span> <span class="nx">Right</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="p">;[...</span><span class="nx">input</span><span class="p">.</span><span class="nf">matchAll</span><span class="p">(</span><span class="nx">regex</span><span class="p">)]</span>
    <span class="p">.</span><span class="nf">forEach</span><span class="p">(({</span>  <span class="na">groups</span><span class="p">:</span> <span class="p">{</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="p">}</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">Left</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span>

      <span class="nx">Right</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">Right</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">||</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">})</span>

  <span class="kd">let</span> <span class="nx">similarity</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">left</span> <span class="k">of</span> <span class="nx">Left</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">similarity</span> <span class="o">+=</span> <span class="nx">left</span> <span class="o">*</span> <span class="p">(</span><span class="nx">Right</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">similarity</span>
<span class="p">}</span>
</code></pre></div></div><p>The code is about the same, though I don’t think the <code class="language-plaintext highlighter-rouge">||</code> (OR) operators are doing favours for readability.</p><p>The object is a little easier to reason about if you’ve don’t know how a map works.</p><p>But this also performs worse compared to the third pass. But only slightly slower.</p><h5 id=fifth-pass-for-funzies>Fifth pass (for funzies)</h5><div class="language-js highlighter-rouge"><div class=highlight><pre class=highlight><code><span class="kd">function</span> <span class="nf">solve</span> <span class="p">(</span><span class="nx">input</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">regex</span> <span class="o">=</span> <span class="sr">/</span><span class="se">(?&lt;</span><span class="sr">left&gt;</span><span class="se">\d</span><span class="sr">+</span><span class="se">)\s</span><span class="sr">+</span><span class="se">(?&lt;</span><span class="sr">right&gt;</span><span class="se">\d</span><span class="sr">+</span><span class="se">)</span><span class="sr">$/gm</span>

  <span class="kd">const</span> <span class="nx">Left</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="kd">const</span> <span class="nx">Right</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="p">;[...</span><span class="nx">input</span><span class="p">.</span><span class="nf">matchAll</span><span class="p">(</span><span class="nx">regex</span><span class="p">)]</span>
    <span class="p">.</span><span class="nf">forEach</span><span class="p">(({</span>  <span class="na">groups</span><span class="p">:</span> <span class="p">{</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="p">}</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">Left</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span>

      <span class="kd">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">Right</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span> <span class="o">??</span> <span class="mi">0</span>
      <span class="nx">Right</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">})</span>

  <span class="kd">let</span> <span class="nx">similarity</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">left</span> <span class="k">of</span> <span class="nx">Left</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">occurrances</span> <span class="o">=</span> <span class="nx">Right</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span> <span class="o">??</span> <span class="mi">0</span>
    <span class="nx">similarity</span> <span class="o">+=</span> <span class="nx">left</span> <span class="o">*</span> <span class="nx">occurrances</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">similarity</span>
<span class="p">}</span>
</code></pre></div></div><p>Instead of the <code class="language-plaintext highlighter-rouge">||</code> (OR) operators, what about nullish coallescence (??)</p><p>This turns out to be more faster than the OR operator, and more stable in timing, but still slower than map.</p><p>I should probably call it there.</p><hr/><h3 id=summary--timings>Summary &amp; Timings</h3><p>I think thats enough approaches to solve the problem.</p><p>Starting with rough solutions and then refining was a good exercise in going through the motions of make it work first make it better later.</p><p>I’m very happy with the operation times, I’m sure there is some amazing algorithm that can do this much faster.</p><table><thead><tr><th>passes (pt1)</th><th>time (ms)</th></tr></thead><tbody><tr><td>1: sample dataset</td><td>0.526166</td></tr><tr><td><strong>2: sample dataset</strong></td><td><strong>0.192042</strong></td></tr><tr><td>1: actual dataset</td><td>1.409791</td></tr><tr><td><strong>2: actual dataset</strong></td><td><strong>1.182459</strong></td></tr></tbody></table><table><thead><tr><th>passes (pt2)</th><th>time (ms)</th></tr></thead><tbody><tr><td>1: sample dataset</td><td>0.136167</td></tr><tr><td>2: sample dataset</td><td>0.328542</td></tr><tr><td>3: sample dataset</td><td>0.168917</td></tr><tr><td>4: sample dataset</td><td>0.28325</td></tr><tr><td><strong>5: sample dataset</strong></td><td><strong>0.123125</strong></td></tr><tr><td>1: actual dataset</td><td>11.550959</td></tr><tr><td>2: actual dataset</td><td>28.845666</td></tr><tr><td><strong>3: actual dataset</strong></td><td><strong>0.640042</strong></td></tr><tr><td>4: actual dataset</td><td>0.847375</td></tr><tr><td>5: actual dataset</td><td>0.802458</td></tr></tbody></table><p>This is also a good reminder to that when testing performance of functions, remember to test against a variety of data. If I had only tested with the sample dataset, I’d lave landed on using an Object instead of a Map for keeping track of numbers and values. Missing out on a 5x improvement on larger data.</p><p>Sub-millisecond solution for part 2 makes me incredibly proud.</p><h4 id=additional-findings>Additional Findings</h4><p>Something really fun to keep in mind when working with NodeJS - the JIT compiler in V8 can do some wonderful things for performance. If you “warm up” the function with a run or two, the operation becomes even faster.</p><table><thead><tr><th>Runs</th><th>time (ms)</th></tr></thead><tbody><tr><td>Run 1: sample dataset</td><td>0.10170799999999858</td></tr><tr><td>Run 2: sample dataset</td><td>0.01087500000000218</td></tr><tr><td>Run 1: actual dataset</td><td>0.6606670000000037</td></tr><tr><td>Run 2: actual dataset</td><td>0.36933299999999747</td></tr></tbody></table><p>The sample dataset reveals a 10x improvement. The dream is crushed with the actual dataset, with only a 2x improvement.</p><hr/><p>Overall, first day was fun! I learned some things about the approaches, and in writing this blog post out, I learned some things about myself.</p></article></main><aside><h2>Projects</h2><nav><ul><li class=""><a href="/project/2023/12/03/hyde-fonts.html"> Hyde Fonts</a></li><li class=""><a href="/project/2023/12/28/fellow-stagg-repair.html"> Fellow Stagg Repair</a></li><li class=""><a href="/project/2023/11/11/turing-pi.html"> Turing Pi</a></li><li class=""><a href="/project/2023/12/22/hyde-decap.html"> Hyde Decap</a></li></ul></nav><a href="/projects">More Projects</a><h2>Notes</h2><nav><ul><li class=""><a href="/note/2024/07/30/callable-class-instance.html"> Callable Class Instance</a></li><li class=""><a href="/note/2024/07/29/web-components.html"> Web Components</a></li><li class=""><a href="/note/2024/02/10/hexdump-shell-command.html"> Hexdump shell command</a></li><li class=""><a href="/note/2023/12/08/fixing-homebrew-permissions.html"> Fixing Homebrew permissions when using ASDF</a></li><li class=""><a href="/note/2021/09/18/node-binary-artifacts.html"> Node CLI / Binary Artifacts</a></li></ul></nav><a href="/notebook">More Notes</a></aside></div><footer><p>©2024 Gregory Daynes</p><nav><ul><li><a href="mailto:email@gregdaynes.com">Contact</a></li><li><a href="/privacy.txt">Privacy</a></li><li><a href="/humans.txt">Humans</a></li><li><a href="/robots.txt">Robots</a></li><li><a href="/sitemap.xml">Site Map</a></li><li><a href="/feed.xml">RSS</a></li><li><a href="/stats">Analytics</a></li></ul></nav><p><small>Content on this site is licensed under Creative Common Attribution-ShareAlike 4.0 International License. All code content is licensed under the MIT license, unless an excerpt from a larger work under another license.</small></p></footer></body></html>